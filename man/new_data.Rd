% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/new-data.R
\name{new_data}
\alias{new_data}
\title{New Data}
\usage{
new_data(
  data,
  seq = character(0),
  ref = list(),
  obs_only = list(character(0)),
  length_out = 30L
)
}
\arguments{
\item{data}{The data frame to generate the new data from.}

\item{seq}{A character vector of the variables to represent as a sequence
in the new data.}

\item{ref}{A named list of reference values for variables
that are not in seq.}

\item{obs_only}{A list of character vectors indicating
the sets of variables to only allow observed combinations for.
If TRUE then obs_only is set to be seq.}

\item{length_out}{A count indicating the length of numeric
and possibly integer sequences.}
}
\value{
A tibble of the new data.
}
\description{
Generates a new data frame that can be passed to a predict function.
The main idea is that most variables are held constant at a reference level
while the variables of interest vary across their range.
\code{new_data} can be thought of as a sophisticated version of \code{\link[=expand.grid]{expand.grid()}}.
}
\details{
The returned variables are of the same class as the original variables while
the rows in the data frame are unique.
Consequently continuous variables such as integers
which have discrete values will not attain the specified \code{length_out} value
if there are too few possible values between the minimum and maximum.

If a factor is named in seq then all levels of the factor are represented
i.e. \code{length_out} is ignored. The only exception to this is
if the factor is named in \code{obs_only}
in which case only observed factor levels are permitted in sequences.

It is worth noting that \code{ref} can be used to specify sequences
for particular values as well
as single references. It is useful for extrapolating outside
the range of the data or changes the levels of a factor.
If an element of ref is a character vector and the corresponding
column is a data frame, then the ref element is assigned the same
factor levels as the column in the data. This is useful for choosing
a factor level without having to set the correct levels.
}
\examples{
library(ggplot2)
library(newdata)

mtcars <- datasets::mtcars

model <- lm(mpg ~ wt + hp + poly(disp, 2), data = mtcars)

# generate a data frame across range of wt with other predictor
# variables held constant
wt <- new_data(mtcars, c("wt"))
head(wt)
#
wt <- cbind(wt, predict(model, newdata = wt, interval = "confidence"))
#
ggplot(data = wt, aes(x = wt, y = fit)) +
  geom_point(data = mtcars, aes(y = mpg)) +
  geom_line() +
  geom_line(aes(y = lwr), linetype = "dotted") +
  geom_line(aes(y = upr), linetype = "dotted") +
  ylab("mpg")

# generate a data frame across range of wt with other predictor
# variables held constant
disp <- new_data(mtcars, c("disp"))
head(disp)

disp <- cbind(disp, predict(model, newdata = disp, interval = "confidence"))
#
ggplot(data = disp, aes(x = disp, y = fit)) +
  geom_point(data = mtcars, aes(y = mpg)) +
  geom_line() +
  geom_line(aes(y = lwr), linetype = "dotted") +
  geom_line(aes(y = upr), linetype = "dotted") +
  ylab("mpg")
}
\seealso{
\code{\link[=new_seq]{new_seq()}} and \code{\link[=new_value]{new_value()}}.
}
